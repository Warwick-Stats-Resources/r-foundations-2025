{
  "hash": "df3e3dee5c78bbfed89d2387d1dba7f4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Programming in R\nsubtitle: R Foundations 2025\nauthor: Ella Kaye, Department of Statistics\ndate: 2025-10-30\ndate-format: long\nformat: warwickpres-revealjs\n---\n\n## Overview\n\n- More on data structures\n\n- Control flow and iteration functions\n\n- Efficient R programming\n\n- Writing functions (basics)\n\n## Introduction\n\nUnderstanding the basics of R programming helps to improve\nanalysis/reporting scripts and extend what we can do with R.\n\nGood coding practice follows the DRY principle: **D**on't **R**epeat **Y**ourself. \nRather than modifying copy-pasted code chunks, we might\n\n- write a custom function\n- use loops or iteration functions to perform multiple similar tasks\n \nCustom functions can be used to provide convenient wrappers to complex \ncode chunks as well as implement novel functionality.\n\n\n# More on data structures {.coral-bg}\n\n## Data structures revisited\n\nFor basic data analysis, our data is usually imported and we use \nhigh-level functions (e.g. from **dplyr**) to handle it.\n\nFor programming, we need to work with lower-level data structures and be\nable to\n\n- create basic objects\n- extract components\n- coerce one data type to another\n\nWorking with base R functions when programming also helps avoid dependencies, which is useful when writing packages.\n\n\n## Vectors\n\n`numeric()`, `character()` and `logical()` can be used to initialize \nvectors of the corresponding type for a given length\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- numeric(3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 0 0\n```\n\n\n:::\n:::\n\n\nElements can be assigned by indexing the positions to be filled, e.g.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx[1] <- 4 # assign 4 to 1st element\nx[-c(2, 3)] <- 4 # assign 4 to everying *except* 2nd and 3rd element\n```\n:::\n\n\nThis is particularly useful when programming an iterative procedure.\n\n`as.logical()`, `as.numeric()` and `as.character()` coerce to the \ncorresponding type, producing `NA`s if coercion fails.\n\n## Logical vectors\n\nLogical vectors are commonly used when indexing. The vector might be \nproduced by a logical operator:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(1, 1, 2, 2, 2)\nx > 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nx[x > 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 2 2\n```\n\n\n:::\n:::\n\n`duplicated()` is also useful here:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nduplicated(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n!duplicated(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n## Numeric vectors\n\nThe are several convenience function for creating\nnumeric vectors, notably `seq()` and `rep()`.\n\nAs they are so useful there are fast shortcuts for\nparticular cases\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nseq_len(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\nfruits <- c(\"apple\", \"pear\", \"banana\")\nseq_along(fruits) # a sequence from 1 to the length of x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nrep.int(1:2, times = c(2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 2 2 2\n```\n\n\n:::\n:::\n\n\n## Character vectors\n\nCharacter vectors may be used for creating names\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 3:5\nnames(x) <- paste0(LETTERS[1:3], 1229:1231)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nA1229 B1230 C1231 \n    3     4     5 \n```\n\n\n:::\n\n```{.r .cell-code}\nnames(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A1229\" \"B1230\" \"C1231\"\n```\n\n\n:::\n:::\n\nNames can be used as an alternative to numeric or logical vectors when indexing\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx[\"B1230\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nB1230 \n    4 \n```\n\n\n:::\n:::\n\n\n## Matrices\n\nA matrix is in fact also a vector, with an attribute giving the dimensions of the matrix\n\n::: {.panel-tabset}\n## default\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nM <- matrix(1:6, 2, 3) # data, nrow, ncol\nM\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(M)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n int [1:2, 1:3] 1 2 3 4 5 6\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(M)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$dim\n[1] 2 3\n```\n\n\n:::\n:::\n\n\n## byrow\nThe `byrow` argument is also useful:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nN <- matrix(1:6, 2, 3, byrow = TRUE) # data, nrow, ncol\nN\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n```\n\n\n:::\n:::\n\n:::\n\n## Matrix functions \n\nUseful functions for matrices include `dim()`, `ncol()`, `nrow()`, \n`colnames()` and `rownames()`. `rbind()` and `cbind()` can be used to \nrow-bind or column-bind vectors.\n\nMatrices enable computation via matrix algebra as well as row/column-wise operations.\n\n## Lists\n\nLists collect together items which may be different types or lengths. Like a \nvector, elements may be named.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nresults <- list(matrix = M, vector = x)\nresults\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$matrix\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n$vector\nA1229 B1230 C1231 \n    3     4     5 \n```\n\n\n:::\n:::\n\n\nLists are often used to return the results of a function. \n\n## Indexing lists\n\nElements can be indexed by `[` to return a list or `[[` to return a \nsingle element, either by index or name:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nresults[\"vector\"] # returns a list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$vector\nA1229 B1230 C1231 \n    3     4     5 \n```\n\n\n:::\n\n```{.r .cell-code}\nresults[[2]] # returns a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nA1229 B1230 C1231 \n    3     4     5 \n```\n\n\n:::\n:::\n\n\n\n`$` can be used to extract elements by name:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nresults$vector # equivalent to results[[\"vector\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nA1229 B1230 C1231 \n    3     4     5 \n```\n\n\n:::\n:::\n\n\n## Data frames\n\nData frames are lists of variables of the same length and hence can often \nbe treated as a matrix \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 1:3\ndat <- data.frame(x = x, id = letters[1:3])\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x id\n1 1  a\n2 2  b\n3 3  c\n```\n\n\n:::\n\n```{.r .cell-code}\ndat[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x\n1 1\n2 2\n3 3\n```\n\n\n:::\n\n```{.r .cell-code}\ndat[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\ndat[1, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\"\n```\n\n\n:::\n:::\n\n\n\n\n## Your turn!\n\nThe `lm` function calls the \"workhorse\" function `lm.fit` to actually \nfit the model. Unlike `lm`, which works from a formula, `lm.fit` works \nfrom the model matrix and the response vector.\n\n1. Define a response `y` containing 10 numeric values. Define an \nexplanatory variable `z` of the numbers 1 to 10.\n\n1. Use the function `cbind()` to create a matrix `x` with `1`s in the first\ncolumn and `z` in the second column.\n\n1. Fit a model using `fit1 <- lm.fit(x, y)`. Use `str` to explore the structure of\nthe results. Use `$` to extract the coefficients.\n\n1. Create a second fit using `lm(y ~ z)`. Use `names` to compare the \nresults. Check the coefficients of the second fit are the same.\n\n## Your turn! (a solution)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# A possible solution\n\nset.seed(1)\ny <- sample(10)\nz <- 1:10\n\nx <- cbind(1, z) # we'll see this trick in a few slides time!\n\nfit1 <- lm.fit(x,y)\nstr(fit1)\nfit1$coefficients\n\nfit2 <- lm(y ~ z)\nnames(fit1)\nnames(fit2)\nfit2$coefficients\n```\n:::\n\n\n## `~` notation\n\nThe `~` notation can be used to specify a model formula, where the LHS is the response and the RHS are a collection of predictors, e.g. \n\n`body_mass_g ~ bill_length_mm + flipper_length_mm`. \n\nThis can be used as the `formula` argument when fitting a model, e.g. a linear model:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlm(body_mass_g ~ bill_length_mm + flipper_length_mm, data = penguins) \n```\n:::\n\n\n. . .\n\nIn the formula, crucially, the `+` does not have to mean it is a linear additive model and should be read more as \"this variable *and* this one etc\" which the model function might use additively (e.g. `lm`) or might not (e.g. many ML models). \n\n::: {.notes}\nThis is a bit of an aside in the context of this session, but discusses a point that Louis Aslett, one of the APTS module leaders, mentioned to me creates confusion in his course.\n:::\n\n# Control flow {.lavendar-bg}\n\n## Control structures\n\nControl structures are the commands that make decisions or execute loops.\n\nConditional execution: `if`/`else`, `switch`\n\nLoops: `for`, `while`, `repeat`\n\n\n## `if`/`else`\n\nAn `if` statement can stand alone or be combined with an `else` statement\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 1:3\nif (all(x > 0)) {\n    res <- mean(x)\n} else {\n    res <- mean(abs(x))\n}\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\nThe condition must evaluate to logical vector of length one. The \nfunctions `all()`, `any()`, `is.na()`, `is.null()` and other `is.`\nfunctions are useful here.\n\n## Conditioning on equality\n\nUsing `==` may not be appropriate as it compares each element; `identical()` will test the whole object\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- y <- 1:2\nx == y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nidentical(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n`all.equal()` will allow for some numerical tolerance.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nz <- sqrt(2)\nidentical(z * z, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nall.equal(z * z, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n## `switch`\n\nThe `switch()` function provides a more readable alternative to nested \n`if` statements\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nif (summary == \"IQR\") { \n    y <- IQR(x)\n} else {\n    if (summary == \"range\"){\n        y <- range(x)\n    } else y <- mean(x)\n}\n```\n:::\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 1:5\nswitch(\"range\", # can enter an arg name or position\n       IQR = IQR(x),\n       range = range(x),\n       mean(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 5\n```\n\n\n:::\n:::\n\n\nThe final unnamed argument is the default. [Further examples](https://www.datamentor.io/r-programming/switch-function/){target=\"_blank}\n\n## `for`\n\nA `for` loop repeats a chunk of code, iterating along the values of a \nvector or list\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(\"apple\", \"pear\")\nfor (nm in x) print(nm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"apple\"\n[1] \"pear\"\n```\n\n\n:::\n:::\n\n\nUnassigned objects are not automatically printed; hence call to `print()`. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfor (i in seq_along(x)) {\n    message(\"Element \", i, \": \", x[i])\n}\n```\n:::\n\n\n`seq_along()` is used here rather than `1:length(x)` as `length(x)` may \nbe zero. `message` is used to print messages to the console.\n\n::: {.notes}\n`message` doesn't produce output on a Quarto slide   \n:::\n\n## `while` and `repeat`\n\nThe `while` loop repeats while a condition is `TRUE`\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nn_iter <- 1\nwhile (n_iter < 3) {\n    x <- x * 2\n    n_iter <- n_iter + 1\n}\n```\n:::\n\n\nThe `repeat` loop repeats until exited by `break`\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrepeat {\n    x <- x + 1\n    if (max(x) > 10) break\n}\n```\n:::\n\n\n`break` can be used in `for` or `while` loops too. \n\n`next` can be used to skip to the next iteration.\n\n\n## Iteration functions\n\nIteration functions provide a general alternative to for loops. They are \nnot necessarily faster, but can be more compact.\n\n`apply()` applies a function over rows/columns of a matrix.\n\n`lapply()`, `sapply()` and `vapply()` iterate over a list or vector. `vapply()` \nis recommended for programming as it specifies the type of return value\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvapply(list(a = 1:3, b = 1:6), FUN = mean, FUN.VALUE = numeric(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  a   b \n2.0 3.5 \n```\n\n\n:::\n:::\n\n`mapply()` iterates over two or more lists/vectors in parallel.\n\n## Iteration function resources\n\n- [Efficient R](https://csgillespie.github.io/efficientR/programming.html#the-apply-family){target=\"_blank\"} by Colin Gillespie and Robin Lovelace\n\n- The built-in help pages. You can directly access the examples using the `example()` function, e.g. to run the `apply()` examples, use `example(\"apply\")`.\n\n- This StackOverflow [answer](https://stackoverflow.com/questions/3505701/grouping-functions-tapply-by-aggregate-and-the-apply-family){target=\"_blank\"}, describing when, where and how to use each of the functions. \n\n- This blog [post](https://nsaunders.wordpress.com/2010/08/20/a-brief-introduction-to-apply-in-r/){target=\"_blank\"} by Neil Saunders\n\n\n## **purrr**\n\nThe [**purrr**](https://purrr.tidyverse.org){target=\"_blank\"} package (part of the tidyverse) provides alternatives to the apply family that have a simpler, more consistent interface with fixed type of return value.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Split a data frame into pieces, \n# fit a model to each piece, summarise and extract R^2\nlibrary(purrr)\n\nmtcars %>%\n  split(.$cyl) %>% # base R\n  map(~ lm(mpg ~ wt, data = .x)) %>% # returns a list\n  map(summary) %>%\n  map_dbl(\"r.squared\") # returns a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        4         6         8 \n0.5086326 0.4645102 0.4229655 \n```\n\n\n:::\n:::\n\n\n\n**Note:** We do need `%>%` not `|>` here. See [here](https://ivelasq.rbind.io/blog/understanding-the-r-pipe/){target=\"_blank\"} for more details.\n\n::: {.notes}\nDo need to use the %>% pipe here, not |>.  \n:::\n\n## Advantages of **purrr**\n\n- The first argument is always the data, so **purrr** works naturally with the pipe.\n\n- All **purrr** functions are type-stable. They always return the advertised output type (e.g. `map()` returns lists; `map_dbl()` returns double vectors), or they throw an error.\n\n- All `map()` functions either accept function, formulas (used for succinctly generating anonymous functions), a character vector (used to extract components by name), or a numeric vector (used to extract by position).\n\nSee the [iteration chapter](https://r4ds.had.co.nz/iteration.html){target=\"_blank\"} of R for Data Science for further examples and details\n\n\n# Efficient R programming {.blue-bg}\n\n## Growing objects\n\nAdding to an object in a loop, e.g. via `c()` or `cbind()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nres <- NULL\nfor (i in 1:10000) res <- c(res, 1)\n```\n:::\n\n\nforces a copy to be made at each iteration. **THIS IS BAD!**\n\nIt is far better to create an object of the necessary size first\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nres <- numeric(10000)\nfor (i in seq_along(res)) res[i] <- 1\n```\n:::\n\n\nTo initialise a list we can use\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nres <- vector(mode = \"list\", length = 100)\n```\n:::\n\n\n\n## Benchmarking\n\nThere will usually be many ways to write code for a given task. To compare\nalternatives, we can benchmark the expression\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(rbenchmark)\nbenchmark({res <- NULL;\n           for (i in 1:10000) res <- c(res, 1)})$elapsed\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11.632\n```\n\n\n:::\n\n```{.r .cell-code}\nbenchmark({res <- numeric(10000)\n           for (i in seq_along(res)) res[i] <- 1})$elapsed\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.081\n```\n\n\n:::\n:::\n\nNote the **BIG** difference between growing and initialising a vector (the latter around 150 times faster in this case).\n\n\n## `for` loops revisited\n\nEach loop has three components:\n\n1. The output: allocate sufficient space before you start the loop\n\n2. The sequence: this determines what you loop over\n\n3. The body: the code that does the work\n\nSee <https://r4ds.had.co.nz/iteration.html#for-loops>\n\n## Vectorization\n\nVectorization is operating on vectors (or vector-like objects) rather than individual elements.\n\nMany operations in R are vectorized, e.g.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 1:3\ny <- 3:1\nx == y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.0000000 0.6931472 1.0986123\n```\n\n\n:::\n\n```{.r .cell-code}\nres <- list(a = 1:3, b = 1:6)\nlengths(res)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b \n3 6 \n```\n\n\n:::\n:::\n\n\nWe do not need to loop through each element!\n\n## Recycling\n\nVectorized functions will recycle shorter vectors to create vectors of \nthe same length\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n1:4 + 0:1 # 1+0, 2+1, 3+0, 4+1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3 3 5\n```\n\n\n:::\n:::\n\nThis is particularly useful for single values\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncbind(1, 3:4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    1    4\n```\n\n\n:::\n:::\n\nand for generating regular patterns\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npaste0(rep(1:3, each = 2), c(\"a\", \"b\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1a\" \"1b\" \"2a\" \"2b\" \"3a\" \"3b\"\n```\n\n\n:::\n:::\n\n\n## Your turn!\n\n1. Write a `for` loop to compute the mean of every column of in `mtcars`, saving each to a preallocated vector\n\n2. Use `lapply()` with `rnorm` to generate a list of length 10 where the 1st item contains a vector of 1 sample from an $N(0,1)$ distribution, the 2nd item contains a vector of 2 samples from an $N(0,1)$ distribution up to the 10th item contains a vector of 10 samples from an $N(0,1)$ distibution.\n\n3. Use `lapply()` with `rnorm` to generate a list of length 10, where the 1st item contains a vector of 5 samples from $N(1,1)$, the 2nd item contains a vector of 5 samples $N(2,1)$ and so on until you get 5 samples from $N(10,1)$\n\n## Your turn! (sample solutions)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nout <- numeric(ncol(mtcars))\n\nfor (i in seq_len(ncol(mtcars))) {\n  out[i] <- mean(mtcars[[i]])\n}\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlapply(1:10, rnorm)\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlapply(1:10, rnorm, n = 5)\n```\n:::\n\n\n## Vectorization and matrices\n\nVectorizations applies to matices too, not only through matrix algebra\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nM <- matrix(1:4, nrow = 2, ncol = 2)\nM + M\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    2    6\n[2,]    4    8\n```\n\n\n:::\n:::\n\nbut also vectorized functions\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nM <- M + 1.3\nround(M)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    2    4\n[2,]    3    5\n```\n\n\n:::\n:::\n\n\n## Matrices and recycling: rows\n\nValues are recycled down matrix, which is convenient for \nrow-wise operations\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nM <- matrix(1:6, nrow = 2, ncol = 3)\nM\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n\n```{.r .cell-code}\nM - 1:2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    0    2    4\n[2,]    0    2    4\n```\n\n\n:::\n:::\n\n\n## Matrices and recycling: columns\n\nTo do the same for columns we would need to explicitly replicate, \nwhich is not so efficient.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nM - rep(1:3, each = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    0    1    2\n[2,]    1    2    3\n```\n\n\n:::\n:::\n\n\n## Vectorization vs `for` loop\n\nOperations that can be vectorized will be more efficient than a loop in R\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nM <- matrix(1:100000, nrow = 200, ncol = 500)\nx <- 1:200\nbenchmark({for (i in 1:200){\n             for (j in 1:500){\n               M[i, j] <- M[i, j] - x[i]\n             }\n           }})$elapsed\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.743\n```\n\n\n:::\n\n```{.r .cell-code}\nbenchmark({M - x})$elapsed\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.024\n```\n\n\n:::\n:::\n\nThe latter is nearly 30 times faster!\n\n## Row/column-wise operations\n\nSeveral functions are available implementing efficient row/column-wise\noperations, e.g. `colMeans()`, `rowMeans()`, `colSums()`, `rowSums()`, `sweep()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nM <- matrix(1:4, nrow = 2, ncol = 2)\nrowMeans(M)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3\n```\n\n\n:::\n:::\n\n\nThese provide an alternative to iterating though rows and columns in R (the \niteration happens in C, which is faster).\n\nThe **matrixStats** package provides further \"matricised\" methods.\n\n## Top tips for efficient programming\n\nA **golden rule** in R programming is to access the underlying C/Fortran routines as quickly as possible; the fewer functions calls required to achieve this, the better. \n\n- Be careful never to grow vectors\n\n- Vectorise code wherever possible\n\nSee [Efficient Programming](https://csgillespie.github.io/efficientR/programming.html){target=\"_blank\"} for more details and examples.\n\nWe will also expand on this topic in the Advanced R course next term.\n\n# Writing functions {.green-bg}\n\n## Components of a function\n\nFunctions are defined by three components:\n\n - the name of the function\n - the arguments of the function, inside `( )`\n - the body of the function that computes the result, inside `{ }`\n \nThey are created using `function()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nt_statistic <- function(n) {\n    x <- rnorm(n)\n    y <- rnorm(n)\n    t.test(x, y)$statistic\n}\n```\n:::\n\n\n## Naming functions\n\nAs with arguments, function names are important:\n\n- use a name that describes what it returns (e.g. `t_statistic`) or what it does (e.g. `remove_na`)\n\n- try to use one convention for combining words (e.g. snake case `t_statistic` or camel case `tStatistic`)\n\n- avoid using the same name as other functions\n\n## Specified arguments\n\n*specified* arguments are those named in the function definition, e.g. \nin `rnorm()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nargs(rnorm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (n, mean = 0, sd = 1) \nNULL\n```\n\n\n:::\n:::\n\nthe arguments are `n`, `mean` and `sd`.\n\n`mean` and `sd` have been given default values in the function definition, but `n` has not, so the function fails if the user does not pass a value to `n`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrnorm()\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in rnorm(): argument \"n\" is missing, with no default\n```\n\n\n:::\n:::\n\n\n## Name and order of arguments\n\nThe user can pass objects to these arguments using their names or by supplying unnamed values in the right order\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrnorm(5, 1, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   6.331252   4.410714  -2.674293 -11.093922   8.841681\n```\n\n\n:::\n\n```{.r .cell-code}\nrnorm(5, sd = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24.153713 16.208097  3.325539 19.987547  8.504005\n```\n\n\n:::\n:::\n\n\nSo naming and order is important! Some guidelines\n\n- put compulsory arguments first, e.g. data\n- put rarely used arguments last, e.g. tolerance setting\n- use short but meaningful argument names\n- if relevant, use the same argument names as similar functions\n\n## Using arguments\n\nArguments are used as objects in the function code.\n\nAn new environment is created each time the function is called, separate \nfrom the global workspace.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 1\ny <- 3\nf <- function(x, y){\n    a <- 1\n    x <- x + a\n    x + y\n}\nf(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\na\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: object 'a' not found\n```\n\n\n:::\n:::\n\n\n## Lexical scoping\n\nIf an object is not defined within the function, or passed in as an argument, R looks for it in the *parent environment* where the function was defined\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- 1\ny <- 3\nf <- function(x){\n    x + y\n}\nf(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nrm(y)\nf(x)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in f(x): object 'y' not found\n```\n\n\n:::\n:::\n\n\nIt is safest (and best practice) to use arguments rather than depend on global variables! \n\n## Return values (single)\n\nBy default, functions return the object created by the last line of code\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf <- function(x) {\n    x <- x + 1\n    log(x)\n}\n```\n:::\n\n\nAlternatively `return()` can be used to terminate the function and return\na given object\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf <- function(x) {\n    if (all(x > 0)) return(log(x))\n    x[x <= 0] <- 0.1\n    log(x)\n}\n```\n:::\n\n\n## Return values (multiple)\n\nMultiple objects can be returned in a list:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmean_and_sd <- function(x) {\n  res_mean <- mean(x, na.rm = TRUE)\n  res_sd <- sd(x)\n  \n  list(mean = res_mean, sd = res_sd)\n}\n\nmean_and_sd(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$mean\n[1] 2\n\n$sd\n[1] 1\n```\n\n\n:::\n:::\n\n\nWe use a list so that we can return different types of objects simultaneously, and access them easily with `$`, e.g. `mean_and_sd(1:3)$mean` returns `2`.\n\n## Your turn!\n\nWrite your own function, `variance`, to compute the variance of a numeric vector:\n\n$$\nVar(x) = \\frac{1}{n-1}\\sum_{i=1}^n(x_i - \\bar{x})^2\n$$\n\nMake use of R's built in vectorisation.\n\nTest it and compare your answer with the built-in `var()` function.\n\n## Your turn! (a solution)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvariance <- function(x) {\n  1/(length(x) - 1) * sum((x - mean(x))^2)\n}\n```\n:::\n\n\n\n# End matter {.yellow-bg}\n\n## Resources\n\nMaterial (very largely) inspired by and remixed from:\n\n- Heather Turner and Erlap Dogu's [R Programming slides](https://www.heatherturner.net/teaching/turkey2018/r_programming/#1){target=\"_blank\"} (with permission)\n\nAdditionally:\n\n- [Efficient R, Chapter 3](https://csgillespie.github.io/efficientR/programming.html#the-apply-family) by Colin Gillespie and Robin Lovelace\n\n- [R for Data Science](https://r4ds.had.co.nz/index.html){target=\"_blank\"}, by Hadley Wickham and Garrett Grolemund, chapters on [iteration](https://r4ds.had.co.nz/iteration.html){target=\"_blank\"} and [functions](https://r4ds.had.co.nz/functions.html){target=\"_blank\"}\n\n## License\n\nLicensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License ([CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/){target=\"_blank\"}).\n\n# Extra stuff we probably won't get to {.blue-bg}\n\n(Use in Fuctions session of Advanced R course in Term 2 instead)\n\n## Unspecified Arguments\n\n`...` or the *ellipsis* allow unspecified arguments to be passed to the function. \n\nThis device is used by functions that work with arbitrary numbers of objects, e.g. \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nargs(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (..., na.rm = FALSE) \nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(1, 4, 10, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 17\n```\n\n\n:::\n:::\n\n\nIt can also be used to pass on arguments to another function, e.g.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nt_statistic <- function(x, g, ...) {\n    t.test(x ~ g, ...)$stat\n}\n```\n:::\n\n\n## Using `...`\n\nArguments passed to `...` can be collected into a\nlist for further analysis\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmeans <- function(...){\n    dots <- list(...)\n    vapply(dots, mean, numeric(1), na.rm = TRUE)\n}\nx <- 1\ny <- 2:3\nmeans(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.0 2.5\n```\n\n\n:::\n:::\n\nSimilarly the objects could be concatenated using `c()`\n\n## Side Effects\n\nA side-effect is a change outside the function that occurs when the\nfunction is run, e.g.\n\n- plot to the graphics window or other device\n- printing output to the console\n- write data to a file\n\nA function *can* have many side-effects and a return value, but it is \nbest practice to have a separate function for each task, e.g creating a \nplot or a table.\n\nWriting to file is usually best done outside a function.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}